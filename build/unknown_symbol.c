/* Autogenerated by zcc. Do not edit. */
#include <stdint.h>
#include <stddef.h>
#include <string.h>
#include "zprog_rt.h"

#define ZPROG_MEM_CAP 65536
#define ZPROG_RET_STACK_CAP 256
enum {
  ZPROG_TRAP_OOB = 1,
  ZPROG_TRAP_CALL_DEPTH = 2,
  ZPROG_TRAP_HOST_MISSING = 3,
  ZPROG_TRAP_HOST_FAIL = 4,
  ZPROG_TRAP_ALLOC = 5,
  ZPROG_TRAP_ARITH = 6
};

static inline int zprog_bounds(int32_t addr, int32_t len) {
  if (addr < 0 || len < 0) return 0;
  size_t end = (size_t)addr + (size_t)len;
  return end <= ZPROG_MEM_CAP;
}

static inline uint16_t zprog_load_u16(const uint8_t* mem, int32_t addr) {
  return (uint16_t)mem[addr] | ((uint16_t)mem[addr + 1] << 8);
}
static inline uint32_t zprog_load_u32(const uint8_t* mem, int32_t addr) {
  return (uint32_t)mem[addr]
      | ((uint32_t)mem[addr + 1] << 8)
      | ((uint32_t)mem[addr + 2] << 16)
      | ((uint32_t)mem[addr + 3] << 24);
}
static inline uint64_t zprog_load_u64(const uint8_t* mem, int32_t addr) {
  return (uint64_t)mem[addr]
      | ((uint64_t)mem[addr + 1] << 8)
      | ((uint64_t)mem[addr + 2] << 16)
      | ((uint64_t)mem[addr + 3] << 24)
      | ((uint64_t)mem[addr + 4] << 32)
      | ((uint64_t)mem[addr + 5] << 40)
      | ((uint64_t)mem[addr + 6] << 48)
      | ((uint64_t)mem[addr + 7] << 56);
}
static inline void zprog_store_u16(uint8_t* mem, int32_t addr, uint16_t v) {
  mem[addr] = (uint8_t)(v & 0xff);
  mem[addr + 1] = (uint8_t)((v >> 8) & 0xff);
}
static inline void zprog_store_u32(uint8_t* mem, int32_t addr, uint32_t v) {
  mem[addr] = (uint8_t)(v & 0xff);
  mem[addr + 1] = (uint8_t)((v >> 8) & 0xff);
  mem[addr + 2] = (uint8_t)((v >> 16) & 0xff);
  mem[addr + 3] = (uint8_t)((v >> 24) & 0xff);
}
static inline void zprog_store_u64(uint8_t* mem, int32_t addr, uint64_t v) {
  mem[addr] = (uint8_t)(v & 0xff);
  mem[addr + 1] = (uint8_t)((v >> 8) & 0xff);
  mem[addr + 2] = (uint8_t)((v >> 16) & 0xff);
  mem[addr + 3] = (uint8_t)((v >> 24) & 0xff);
  mem[addr + 4] = (uint8_t)((v >> 32) & 0xff);
  mem[addr + 5] = (uint8_t)((v >> 40) & 0xff);
  mem[addr + 6] = (uint8_t)((v >> 48) & 0xff);
  mem[addr + 7] = (uint8_t)((v >> 56) & 0xff);
}
static inline int32_t zprog_clz32(uint32_t v) {
  if (v == 0) return 32;
  int32_t n = 0;
  while ((v & (1u << 31)) == 0) { n++; v <<= 1; }
  return n;
}
static inline int32_t zprog_ctz32(uint32_t v) {
  if (v == 0) return 32;
  int32_t n = 0;
  while ((v & 1u) == 0) { n++; v >>= 1; }
  return n;
}
static inline int32_t zprog_popc32(uint32_t v) {
  int32_t n = 0;
  while (v) { n += (int32_t)(v & 1u); v >>= 1; }
  return n;
}
static inline int32_t zprog_clz64(uint64_t v) {
  if (v == 0) return 64;
  int32_t n = 0;
  while ((v & (1ULL << 63)) == 0) { n++; v <<= 1; }
  return n;
}
static inline int32_t zprog_ctz64(uint64_t v) {
  if (v == 0) return 64;
  int32_t n = 0;
  while ((v & 1ULL) == 0) { n++; v >>= 1; }
  return n;
}
static inline int32_t zprog_popc64(uint64_t v) {
  int32_t n = 0;
  while (v) { n += (int32_t)(v & 1ULL); v >>= 1; }
  return n;
}

enum { ZPROG_HEAP_BASE = 0 };

static const uint32_t ZPROG_HEAP_BASE_CONST = ZPROG_HEAP_BASE;
uint32_t zprog_heap_base_value(void) { return ZPROG_HEAP_BASE_CONST; }

struct zprog_state {
  int32_t HL;
  int32_t DE;
  int32_t A;
  int32_t BC;
  int32_t IX;
  int32_t cmp;
  int64_t HL64;
  int64_t DE64;
  int64_t BC64;
  int64_t IX64;
  uint8_t mem[ZPROG_MEM_CAP];
};

static void zprog_state_init(struct zprog_state* state) {
  memset(state, 0, sizeof(*state));
}

int lembeh_handle(int32_t req_handle,
                  int32_t res_handle,
                  zprog_in_fn in_fn,
                  zprog_out_fn out_fn,
                  zprog_end_fn end_fn,
                  zprog_log_fn log_fn,
                  zprog_ctl_fn ctl_fn,
                  void* host_ctx,
                  const struct zprog_sys* sys) {
  (void)out_fn; /* may be unused */
  (void)end_fn;
  (void)log_fn;
  (void)ctl_fn;
  struct zprog_state state;
  zprog_state_init(&state);
  int32_t pc = 0;
  int32_t ret_stack[ZPROG_RET_STACK_CAP];
  int32_t sp = 0;
  for (;;) {
    switch (pc) {
    case 0: { /* line -1 LD */
