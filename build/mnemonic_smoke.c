/* Autogenerated by zcc. Do not edit. */
#include <stdint.h>
#include <stddef.h>
#include <string.h>
#include "zprog_rt.h"

#define ZPROG_MEM_CAP 65600
#define ZPROG_RET_STACK_CAP 256
enum {
  ZPROG_TRAP_OOB = 1,
  ZPROG_TRAP_CALL_DEPTH = 2,
  ZPROG_TRAP_HOST_MISSING = 3,
  ZPROG_TRAP_HOST_FAIL = 4,
  ZPROG_TRAP_ALLOC = 5,
  ZPROG_TRAP_ARITH = 6
};

static inline int zprog_bounds(int32_t addr, int32_t len) {
  if (addr < 0 || len < 0) return 0;
  size_t end = (size_t)addr + (size_t)len;
  return end <= ZPROG_MEM_CAP;
}

static inline uint16_t zprog_load_u16(const uint8_t* mem, int32_t addr) {
  return (uint16_t)mem[addr] | ((uint16_t)mem[addr + 1] << 8);
}
static inline uint32_t zprog_load_u32(const uint8_t* mem, int32_t addr) {
  return (uint32_t)mem[addr]
      | ((uint32_t)mem[addr + 1] << 8)
      | ((uint32_t)mem[addr + 2] << 16)
      | ((uint32_t)mem[addr + 3] << 24);
}
static inline uint64_t zprog_load_u64(const uint8_t* mem, int32_t addr) {
  return (uint64_t)mem[addr]
      | ((uint64_t)mem[addr + 1] << 8)
      | ((uint64_t)mem[addr + 2] << 16)
      | ((uint64_t)mem[addr + 3] << 24)
      | ((uint64_t)mem[addr + 4] << 32)
      | ((uint64_t)mem[addr + 5] << 40)
      | ((uint64_t)mem[addr + 6] << 48)
      | ((uint64_t)mem[addr + 7] << 56);
}
static inline void zprog_store_u16(uint8_t* mem, int32_t addr, uint16_t v) {
  mem[addr] = (uint8_t)(v & 0xff);
  mem[addr + 1] = (uint8_t)((v >> 8) & 0xff);
}
static inline void zprog_store_u32(uint8_t* mem, int32_t addr, uint32_t v) {
  mem[addr] = (uint8_t)(v & 0xff);
  mem[addr + 1] = (uint8_t)((v >> 8) & 0xff);
  mem[addr + 2] = (uint8_t)((v >> 16) & 0xff);
  mem[addr + 3] = (uint8_t)((v >> 24) & 0xff);
}
static inline void zprog_store_u64(uint8_t* mem, int32_t addr, uint64_t v) {
  mem[addr] = (uint8_t)(v & 0xff);
  mem[addr + 1] = (uint8_t)((v >> 8) & 0xff);
  mem[addr + 2] = (uint8_t)((v >> 16) & 0xff);
  mem[addr + 3] = (uint8_t)((v >> 24) & 0xff);
  mem[addr + 4] = (uint8_t)((v >> 32) & 0xff);
  mem[addr + 5] = (uint8_t)((v >> 40) & 0xff);
  mem[addr + 6] = (uint8_t)((v >> 48) & 0xff);
  mem[addr + 7] = (uint8_t)((v >> 56) & 0xff);
}
static inline int32_t zprog_clz32(uint32_t v) {
  if (v == 0) return 32;
  int32_t n = 0;
  while ((v & (1u << 31)) == 0) { n++; v <<= 1; }
  return n;
}
static inline int32_t zprog_ctz32(uint32_t v) {
  if (v == 0) return 32;
  int32_t n = 0;
  while ((v & 1u) == 0) { n++; v >>= 1; }
  return n;
}
static inline int32_t zprog_popc32(uint32_t v) {
  int32_t n = 0;
  while (v) { n += (int32_t)(v & 1u); v >>= 1; }
  return n;
}
static inline int32_t zprog_clz64(uint64_t v) {
  if (v == 0) return 64;
  int32_t n = 0;
  while ((v & (1ULL << 63)) == 0) { n++; v <<= 1; }
  return n;
}
static inline int32_t zprog_ctz64(uint64_t v) {
  if (v == 0) return 64;
  int32_t n = 0;
  while ((v & 1ULL) == 0) { n++; v >>= 1; }
  return n;
}
static inline int32_t zprog_popc64(uint64_t v) {
  int32_t n = 0;
  while (v) { n += (int32_t)(v & 1ULL); v >>= 1; }
  return n;
}

enum { ZPROG_HEAP_BASE = 64 };

static const uint32_t ZPROG_HEAP_BASE_CONST = ZPROG_HEAP_BASE;
uint32_t zprog_heap_base_value(void) { return ZPROG_HEAP_BASE_CONST; }

struct zprog_state {
  int32_t HL;
  int32_t DE;
  int32_t A;
  int32_t BC;
  int32_t IX;
  int32_t cmp;
  int64_t HL64;
  int64_t DE64;
  int64_t BC64;
  int64_t IX64;
  uint8_t mem[ZPROG_MEM_CAP];
};

static const uint8_t zprog_seg_0[] = {
  0x7f, 0x80
};

static const uint8_t zprog_seg_1[] = {
  0x78, 0x56, 0x34, 0x12
};

static const uint8_t zprog_seg_2[] = {
  0x08, 0x07, 0x06, 0x05, 0x04, 0x03, 0x02, 0x01
};

static const uint8_t zprog_seg_3[] = {
  0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08
};

static const uint8_t zprog_seg_4[] = {
  0x6d, 0x6e, 0x65, 0x6d, 0x6f, 0x6e, 0x69, 0x63, 0x20, 0x73, 0x6d, 0x6f, 0x6b, 0x65
};

static void zprog_state_init(struct zprog_state* state) {
  memset(state, 0, sizeof(*state));
  memcpy(state->mem + 0, zprog_seg_0, 2);
  memcpy(state->mem + 4, zprog_seg_1, 4);
  memcpy(state->mem + 8, zprog_seg_2, 8);
  memcpy(state->mem + 16, zprog_seg_3, 8);
  memcpy(state->mem + 48, zprog_seg_4, 14);
}

enum {
  ZSYM_const_two = 2,
  ZSYM_buf8 = 0,
  ZSYM_buf16 = 4660,
  ZSYM_buf32 = 4,
  ZSYM_buf64 = 8,
  ZSYM_buf64b = 16,
  ZSYM_out8 = 24,
  ZSYM_out16 = 28,
  ZSYM_out32 = 32,
  ZSYM_out64 = 36,
  ZSYM_fill_buf = 44,
  ZSYM_msg = 48,
  ZSYM_msg_len = 14,
};

int lembeh_handle(int32_t req_handle,
                  int32_t res_handle,
                  zprog_in_fn in_fn,
                  zprog_out_fn out_fn,
                  zprog_end_fn end_fn,
                  zprog_log_fn log_fn,
                  zprog_ctl_fn ctl_fn,
                  void* host_ctx,
                  const struct zprog_sys* sys) {
  (void)out_fn; /* may be unused */
  (void)end_fn;
  (void)log_fn;
  (void)ctl_fn;
  struct zprog_state state;
  zprog_state_init(&state);
  int32_t pc = 0;
  int32_t ret_stack[ZPROG_RET_STACK_CAP];
  int32_t sp = 0;
  for (;;) {
    switch (pc) {
    case 0: { /* line -1 LD */
      state.HL = (int32_t)0;
      pc = 1;
      break;
    }
    case 1: { /* line -1 LD */
      if (!zprog_bounds(state.HL, 1)) return ZPROG_TRAP_OOB;
      state.A = state.mem[state.HL];
      pc = 2;
      break;
    }
    case 2: { /* line -1 LD */
      if (!zprog_bounds(state.HL, 1)) return ZPROG_TRAP_OOB;
      state.mem[state.HL] = (uint8_t)(state.A & 0xff);
      pc = 3;
      break;
    }
    case 3: { /* line -1 LD */
      state.HL = (int32_t)100;
      pc = 4;
      break;
    }
    case 4: { /* line -1 LD */
      state.DE = (int32_t)25;
      pc = 5;
      break;
    }
    case 5: { /* line -1 LD */
      state.BC = (int32_t)4;
      pc = 6;
      break;
    }
    case 6: { /* line -1 LD */
      state.IX = (int32_t)3;
      pc = 7;
      break;
    }
    case 7: { /* line -1 ADD */
      state.HL += state.DE;
      pc = 8;
      break;
    }
    case 8: { /* line -1 SUB */
      state.HL -= (int32_t)5;
      pc = 9;
      break;
    }
    case 9: { /* line -1 MUL */
      state.HL *= (int32_t)3;
      pc = 10;
      break;
    }
    case 10: { /* line -1 DIVS */
      { int32_t rhs = (int32_t)2;
        if (rhs == 0 || (state.HL == INT32_MIN && rhs == -1)) return ZPROG_TRAP_ARITH;
        state.HL /= rhs; }
      pc = 11;
      break;
    }
    case 11: { /* line -1 DIVU */
      { uint32_t rhs = (uint32_t)((int32_t)2);
        if (rhs == 0) return ZPROG_TRAP_ARITH;
        state.HL = (int32_t)((uint32_t)state.HL / rhs); }
      pc = 12;
      break;
    }
    case 12: { /* line -1 REMS */
      { int32_t rhs = (int32_t)2;
        if (rhs == 0 || (state.HL == INT32_MIN && rhs == -1)) return ZPROG_TRAP_ARITH;
        state.HL %= rhs; }
      pc = 13;
      break;
    }
    case 13: { /* line -1 REMU */
      { uint32_t rhs = (uint32_t)((int32_t)2);
        if (rhs == 0) return ZPROG_TRAP_ARITH;
        state.HL = (int32_t)((uint32_t)state.HL % rhs); }
      pc = 14;
      break;
    }
    case 14: { /* line -1 AND */
      state.HL &= (int32_t)255;
      pc = 15;
      break;
    }
    case 15: { /* line -1 OR */
      state.HL |= (int32_t)16;
      pc = 16;
      break;
    }
    case 16: { /* line -1 XOR */
      state.HL ^= (int32_t)5;
      pc = 17;
      break;
    }
    case 17: { /* line -1 EQ */
      state.HL = (state.HL == (int32_t)0) ? 1 : 0;
      pc = 18;
      break;
    }
    case 18: { /* line -1 NE */
      state.HL = (state.HL != (int32_t)1) ? 1 : 0;
      pc = 19;
      break;
    }
    case 19: { /* line -1 LTS */
      state.HL = (state.HL < (int32_t)10) ? 1 : 0;
      pc = 20;
      break;
    }
    case 20: { /* line -1 LTU */
      state.HL = ((uint32_t)state.HL < (uint32_t)((int32_t)10)) ? 1 : 0;
      pc = 21;
      break;
    }
    case 21: { /* line -1 LES */
      state.HL = (state.HL <= (int32_t)10) ? 1 : 0;
      pc = 22;
      break;
    }
    case 22: { /* line -1 LEU */
      state.HL = ((uint32_t)state.HL <= (uint32_t)((int32_t)10)) ? 1 : 0;
      pc = 23;
      break;
    }
    case 23: { /* line -1 GTS */
      state.HL = (state.HL > (int32_t)10) ? 1 : 0;
      pc = 24;
      break;
    }
    case 24: { /* line -1 GTU */
      state.HL = ((uint32_t)state.HL > (uint32_t)((int32_t)10)) ? 1 : 0;
      pc = 25;
      break;
    }
    case 25: { /* line -1 GES */
      state.HL = (state.HL >= (int32_t)10) ? 1 : 0;
      pc = 26;
      break;
    }
    case 26: { /* line -1 GEU */
      state.HL = ((uint32_t)state.HL >= (uint32_t)((int32_t)10)) ? 1 : 0;
      pc = 27;
      break;
    }
    case 27: { /* line -1 SLA */
      { uint32_t shift = (uint32_t)((int32_t)1) & 31u;
        uint32_t v = (uint32_t)state.HL;
        state.HL = (int32_t)(v << shift); }
      pc = 28;
      break;
    }
    case 28: { /* line -1 SRA */
      { uint32_t shift = (uint32_t)((int32_t)1) & 31u;
        int32_t v = state.HL;
        state.HL = (int32_t)(v >> shift); }
      pc = 29;
      break;
    }
    case 29: { /* line -1 SRL */
      { uint32_t shift = (uint32_t)((int32_t)1) & 31u;
        uint32_t v = (uint32_t)state.HL;
        state.HL = (int32_t)(v >> shift); }
      pc = 30;
      break;
    }
    case 30: { /* line -1 ROL */
      { uint32_t shift = (uint32_t)((int32_t)1) & 31u;
        uint32_t v = (uint32_t)state.HL;
        if (shift) v = (v << shift) | (v >> (32 - shift));
        state.HL = (int32_t)v; }
      pc = 31;
      break;
    }
    case 31: { /* line -1 ROR */
      { uint32_t shift = (uint32_t)((int32_t)1) & 31u;
        uint32_t v = (uint32_t)state.HL;
        if (shift) v = (v >> shift) | (v << (32 - shift));
        state.HL = (int32_t)v; }
      pc = 32;
      break;
    }
    case 32: { /* line -1 CLZ */
      state.HL = zprog_clz32((uint32_t)state.HL);
      pc = 33;
      break;
    }
    case 33: { /* line -1 CTZ */
      state.HL = zprog_ctz32((uint32_t)state.HL);
      pc = 34;
      break;
    }
    case 34: { /* line -1 POPC */
      state.HL = zprog_popc32((uint32_t)state.HL);
      pc = 35;
      break;
    }
    case 35: { /* line -1 DROP */
      state.IX = 0;
      pc = 36;
      break;
    }
    case 36: { /* line -1 LD8S */
      if (!zprog_bounds((int32_t)0, 1)) return ZPROG_TRAP_OOB;
      state.BC = (int32_t)(int8_t)state.mem[(int32_t)0];
      pc = 37;
      break;
    }
    case 37: { /* line -1 LD8U */
      if (!zprog_bounds((int32_t)0, 1)) return ZPROG_TRAP_OOB;
      state.DE = (int32_t)state.mem[(int32_t)0];
      pc = 38;
      break;
    }
    case 38: { /* line -1 LD16S */
      if (!zprog_bounds((int32_t)4660, 2)) return ZPROG_TRAP_OOB;
      state.IX = (int32_t)(int16_t)zprog_load_u16(state.mem, (int32_t)4660);
      pc = 39;
      break;
    }
    case 39: { /* line -1 LD16U */
      if (!zprog_bounds((int32_t)4660, 2)) return ZPROG_TRAP_OOB;
      state.HL = (int32_t)zprog_load_u16(state.mem, (int32_t)4660);
      pc = 40;
      break;
    }
    case 40: { /* line -1 LD32 */
      if (!zprog_bounds((int32_t)4, 4)) return ZPROG_TRAP_OOB;
      state.DE = (int32_t)zprog_load_u32(state.mem, (int32_t)4);
      pc = 41;
      break;
    }
    case 41: { /* line -1 LD */
      state.A = (int32_t)90;
      pc = 42;
      break;
    }
    case 42: { /* line -1 ST8 */
      if (!zprog_bounds((int32_t)24, 1)) return ZPROG_TRAP_OOB;
      state.mem[(int32_t)24] = (uint8_t)(state.A & 0xff);
      pc = 43;
      break;
    }
    case 43: { /* line -1 ST16 */
      if (!zprog_bounds((int32_t)28, 2)) return ZPROG_TRAP_OOB;
      zprog_store_u16(state.mem, (int32_t)28, (uint16_t)state.BC);
      pc = 44;
      break;
    }
    case 44: { /* line -1 ST32 */
      if (!zprog_bounds((int32_t)32, 4)) return ZPROG_TRAP_OOB;
      zprog_store_u32(state.mem, (int32_t)32, (uint32_t)state.DE);
      pc = 45;
      break;
    }
    case 45: { /* line -1 LD */
      state.HL = (int32_t)4;
      pc = 46;
      break;
    }
    case 46: { /* line -1 LD */
      state.DE = (int32_t)32;
      pc = 47;
      break;
    }
    case 47: { /* line -1 LD */
      state.BC = (int32_t)4;
      pc = 48;
      break;
    }
    case 48: { /* line -1 LDIR */
      if (!zprog_bounds(state.HL, state.BC)) return ZPROG_TRAP_OOB;
      if (!zprog_bounds(state.DE, state.BC)) return ZPROG_TRAP_OOB;
      memmove(state.mem + state.DE, state.mem + state.HL, (size_t)state.BC);
      pc = 49;
      break;
    }
    case 49: { /* line -1 LD */
      state.HL = (int32_t)44;
      pc = 50;
      break;
    }
    case 50: { /* line -1 LD */
      state.BC = (int32_t)4;
      pc = 51;
      break;
    }
    case 51: { /* line -1 LD */
      state.A = (int32_t)170;
      pc = 52;
      break;
    }
    case 52: { /* line -1 FILL */
      if (!zprog_bounds(state.HL, state.BC)) return ZPROG_TRAP_OOB;
      memset(state.mem + state.HL, (uint8_t)(state.A & 0xff), (size_t)state.BC);
      pc = 53;
      break;
    }
    case 53: { /* line -1 LD64 */
      if (!zprog_bounds((int32_t)8, 8)) return ZPROG_TRAP_OOB;
      state.HL64 = (int64_t)zprog_load_u64(state.mem, (int32_t)8);
      pc = 54;
      break;
    }
    case 54: { /* line -1 LD64 */
      if (!zprog_bounds((int32_t)16, 8)) return ZPROG_TRAP_OOB;
      state.DE64 = (int64_t)zprog_load_u64(state.mem, (int32_t)16);
      pc = 55;
      break;
    }
    case 55: { /* line -1 LD64 */
      if (!zprog_bounds((int32_t)16, 8)) return ZPROG_TRAP_OOB;
      state.BC64 = (int64_t)zprog_load_u64(state.mem, (int32_t)16);
      pc = 56;
      break;
    }
    case 56: { /* line -1 ADD64 */
      state.HL64 += state.DE64;
      pc = 57;
      break;
    }
    case 57: { /* line -1 SUB64 */
      state.HL64 -= (int64_t)2;
      pc = 58;
      break;
    }
    case 58: { /* line -1 MUL64 */
      state.HL64 *= (int64_t)3;
      pc = 59;
      break;
    }
    case 59: { /* line -1 DIVS64 */
      { int64_t rhs = (int64_t)2;
        if (rhs == 0 || (state.HL64 == INT64_MIN && rhs == -1)) return ZPROG_TRAP_ARITH;
        state.HL64 /= rhs; }
      pc = 60;
      break;
    }
    case 60: { /* line -1 DIVU64 */
      { uint64_t rhs = (uint64_t)((int64_t)2);
        if (rhs == 0) return ZPROG_TRAP_ARITH;
        state.HL64 = (int64_t)((uint64_t)state.HL64 / rhs); }
      pc = 61;
      break;
    }
    case 61: { /* line -1 REMS64 */
      { int64_t rhs = (int64_t)2;
        if (rhs == 0 || (state.HL64 == INT64_MIN && rhs == -1)) return ZPROG_TRAP_ARITH;
        state.HL64 %= rhs; }
      pc = 62;
      break;
    }
    case 62: { /* line -1 REMU64 */
      { uint64_t rhs = (uint64_t)((int64_t)2);
        if (rhs == 0) return ZPROG_TRAP_ARITH;
        state.HL64 = (int64_t)((uint64_t)state.HL64 % rhs); }
      pc = 63;
      break;
    }
    case 63: { /* line -1 AND64 */
      state.HL64 &= (int64_t)255;
      pc = 64;
      break;
    }
    case 64: { /* line -1 OR64 */
      state.HL64 |= (int64_t)16;
      pc = 65;
      break;
    }
    case 65: { /* line -1 XOR64 */
      state.HL64 ^= (int64_t)5;
      pc = 66;
      break;
    }
    case 66: { /* line -1 EQ64 */
      state.HL64 = (state.HL64 == (int64_t)0) ? 1 : 0;
      pc = 67;
      break;
    }
    case 67: { /* line -1 NE64 */
      state.HL64 = (state.HL64 != (int64_t)1) ? 1 : 0;
      pc = 68;
      break;
    }
    case 68: { /* line -1 LTS64 */
      state.HL64 = (state.HL64 < state.DE64) ? 1 : 0;
      pc = 69;
      break;
    }
    case 69: { /* line -1 LTU64 */
      state.HL64 = ((uint64_t)state.HL64 < (uint64_t)(state.DE64)) ? 1 : 0;
      pc = 70;
      break;
    }
    case 70: { /* line -1 LES64 */
      state.HL64 = (state.HL64 <= (int64_t)100) ? 1 : 0;
      pc = 71;
      break;
    }
    case 71: { /* line -1 LEU64 */
      state.HL64 = ((uint64_t)state.HL64 <= (uint64_t)((int64_t)100)) ? 1 : 0;
      pc = 72;
      break;
    }
    case 72: { /* line -1 GTS64 */
      state.HL64 = (state.HL64 > (int64_t)100) ? 1 : 0;
      pc = 73;
      break;
    }
    case 73: { /* line -1 GTU64 */
      state.HL64 = ((uint64_t)state.HL64 > (uint64_t)((int64_t)100)) ? 1 : 0;
      pc = 74;
      break;
    }
    case 74: { /* line -1 GES64 */
      state.HL64 = (state.HL64 >= (int64_t)100) ? 1 : 0;
      pc = 75;
      break;
    }
    case 75: { /* line -1 GEU64 */
      state.HL64 = ((uint64_t)state.HL64 >= (uint64_t)((int64_t)100)) ? 1 : 0;
      pc = 76;
      break;
    }
    case 76: { /* line -1 SLA64 */
      { uint64_t shift = (uint64_t)((int64_t)1) & 63u;
        uint64_t v = (uint64_t)state.HL64;
        state.HL64 = (int64_t)(v << shift); }
      pc = 77;
      break;
    }
    case 77: { /* line -1 SRA64 */
      { uint64_t shift = (uint64_t)((int64_t)1) & 63u;
        int64_t v = state.HL64;
        state.HL64 = (int64_t)(v >> shift); }
      pc = 78;
      break;
    }
    case 78: { /* line -1 SRL64 */
      { uint64_t shift = (uint64_t)((int64_t)1) & 63u;
        uint64_t v = (uint64_t)state.HL64;
        state.HL64 = (int64_t)(v >> shift); }
      pc = 79;
      break;
    }
    case 79: { /* line -1 ROL64 */
      { uint64_t shift = (uint64_t)((int64_t)1) & 63u;
        uint64_t v = (uint64_t)state.HL64;
        if (shift) v = (v << shift) | (v >> (64 - shift));
        state.HL64 = (int64_t)v; }
      pc = 80;
      break;
    }
    case 80: { /* line -1 ROR64 */
      { uint64_t shift = (uint64_t)((int64_t)1) & 63u;
        uint64_t v = (uint64_t)state.HL64;
        if (shift) v = (v >> shift) | (v << (64 - shift));
        state.HL64 = (int64_t)v; }
      pc = 81;
      break;
    }
    case 81: { /* line -1 CLZ64 */
      state.HL64 = (int64_t)zprog_clz64((uint64_t)state.HL64);
      pc = 82;
      break;
    }
    case 82: { /* line -1 CTZ64 */
      state.DE64 = (int64_t)zprog_ctz64((uint64_t)state.DE64);
      pc = 83;
      break;
    }
    case 83: { /* line -1 POPC64 */
      state.BC64 = (int64_t)zprog_popc64((uint64_t)state.BC64);
      pc = 84;
      break;
    }
    case 84: { /* line -1 LD8S64 */
      if (!zprog_bounds((int32_t)0, 1)) return ZPROG_TRAP_OOB;
      state.HL64 = (int64_t)(int8_t)state.mem[(int32_t)0];
      pc = 85;
      break;
    }
    case 85: { /* line -1 LD8U64 */
      if (!zprog_bounds((int32_t)0, 1)) return ZPROG_TRAP_OOB;
      state.DE64 = (int64_t)state.mem[(int32_t)0];
      pc = 86;
      break;
    }
    case 86: { /* line -1 LD16S64 */
      if (!zprog_bounds((int32_t)4660, 2)) return ZPROG_TRAP_OOB;
      state.BC64 = (int64_t)(int16_t)zprog_load_u16(state.mem, (int32_t)4660);
      pc = 87;
      break;
    }
    case 87: { /* line -1 LD16U64 */
      if (!zprog_bounds((int32_t)4660, 2)) return ZPROG_TRAP_OOB;
      state.IX64 = (int64_t)zprog_load_u16(state.mem, (int32_t)4660);
      pc = 88;
      break;
    }
    case 88: { /* line -1 LD32S64 */
      if (!zprog_bounds((int32_t)4, 4)) return ZPROG_TRAP_OOB;
      state.HL64 = (int64_t)(int32_t)zprog_load_u32(state.mem, (int32_t)4);
      pc = 89;
      break;
    }
    case 89: { /* line -1 LD32U64 */
      if (!zprog_bounds((int32_t)4, 4)) return ZPROG_TRAP_OOB;
      state.DE64 = (int64_t)zprog_load_u32(state.mem, (int32_t)4);
      pc = 90;
      break;
    }
    case 90: { /* line -1 ST8_64 */
      if (!zprog_bounds((int32_t)24, 1)) return ZPROG_TRAP_OOB;
      state.mem[(int32_t)24] = (uint8_t)(state.HL64 & 0xff);
      pc = 91;
      break;
    }
    case 91: { /* line -1 ST16_64 */
      if (!zprog_bounds((int32_t)28, 2)) return ZPROG_TRAP_OOB;
      zprog_store_u16(state.mem, (int32_t)28, (uint16_t)state.DE64);
      pc = 92;
      break;
    }
    case 92: { /* line -1 ST32_64 */
      if (!zprog_bounds((int32_t)32, 4)) return ZPROG_TRAP_OOB;
      zprog_store_u32(state.mem, (int32_t)32, (uint32_t)state.BC64);
      pc = 93;
      break;
    }
    case 93: { /* line -1 ST64 */
      if (!zprog_bounds((int32_t)36, 8)) return ZPROG_TRAP_OOB;
      zprog_store_u64(state.mem, (int32_t)36, (uint64_t)state.HL64);
      pc = 94;
      break;
    }
    case 94: { /* line -1 LD */
      state.HL = (int32_t)48;
      pc = 95;
      break;
    }
    case 95: { /* line -1 LD */
      state.DE = (int32_t)14;
      pc = 96;
      break;
    }
    case 96: { /* line -1 CALL */
      if (!out_fn) return ZPROG_TRAP_HOST_MISSING;
      if (!zprog_bounds(state.HL, state.DE)) return ZPROG_TRAP_OOB;
      if (out_fn(host_ctx, res_handle, state.mem, ZPROG_MEM_CAP, state.HL, state.DE) < 0) return ZPROG_TRAP_HOST_FAIL;
      pc = 97;
      break;
    }
    case 97: { /* line -1 RET */
      if (sp == 0) return 0;
      pc = ret_stack[--sp];
      break;
    }
      default: return 0;
    }
  }
}
